<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python自动化面试一]]></title>
    <url>%2F2019%2F04%2F22%2Fpython%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E4%B8%80%2F</url>
    <content type="text"><![CDATA[常见的python自动化测试的面试题目1. 给定一个只包含正整数的非空数组,返回该数组中重复次数最多的前N个数字,返回的结果按重复次数从多到少降序排列(N不存在取值非法的情况)方法一：123456789101112131415def ele_sort(data,n): d=&#123;&#125; for i in data: d[i]=data.count(i) #将元素出现的次数 作为字典键值对的value值，组成（i:d[i]==&gt;元素：元素出现的次数） print(d.items()) #type(d.items())--&gt;&lt;class 'dict_items'&gt; sort_data = sorted(d.items(),key=lambda item:item[1],reverse=True) for i in range(0,n): print('排名第&#123;&#125;的元素：&#123;&#125;，出现了&#123;&#125;次'.format(i+1,sort_data[i][0],sort_data[i][1]))if __name__ == '__main__': l = [3, 4, 5, 3, 2, 5, 6, 2, 8, 9, 2, 4, 2, 5, 6, 3, 2, 4, 5, 5, 3, 2, 1, 5, 6, 5] n = int(input('请输入小于元素个数的正整数：')) ele_sort(l,n) 方法二：（使用set集合操作） 12345678910111213141516def data_sort(data,n): data_new = set(data) #将重复的数据去掉 d=&#123;&#125; for i in data_new: d[i]=data.count(i) print(d.items()) list_data = sorted(d.items(),key=lambda item:item[1],reverse=True) for i in range(0,n): print('排名第&#123;&#125;的元素：&#123;&#125;，出现&#123;&#125;次'.format(i+1,list_data[i][0],list_data[i][1]))if __name__ == '__main__': l = [3, 4, 5, 3, 2, 5, 6, 2, 8, 9, 2, 4, 2, 5, 6, 3, 2, 4, 5, 5, 3, 2, 1, 5, 6, 5] n=int(input('请输入小于元素个数&#123;&#125;的正整数：'.format(len(set(l))))) data_sort(l,n) 代码难点解读:123456789d.items()： 1. 它的数据类型是：dict_items 以列表返回可遍历的(键, 值) 元组数组 2. 注意：返回不是列表：是一个存放多个元祖的高仿列表，[(key,value),(key,value),(key,value)...] 3. 不能用下标，可用for循环sorted(d.items(),key=lambda item:item[1],reverse=True) 1. sorted(iterable,key,reverse)函数,参数key来决定我们根据那个字段对列表元素进行排序, 2. sorted(iterable，key，reverse)函数返回一个新列表，其中包含按升序排列的iterable中的所有项 3. key=lambda 元素: 元素[字段索引] 4. lambda item:item[1] 表示对元素第二个字段(就是 value)进行排序 2. 从字符串‘abcdba‘中找出第一个不重复的字符，方法不限方法一： 使用count()函数 （查看元素在数据中出现的次数）1234567891011def find_ele(data): for i in data: if data.count(i)==1: #元素在数据data出现的次数 print('第一个不重复的字符是：&#123;&#125;'.format(i)) breakif __name__ == '__main__': s= input('请输入随意的字符串：') find_ele(s) 方法二： 使用split()切割函数(切割后 长度为2 说明该元素只存在一个)1234567891011def find_ele(data): for i in data: if len (data.split (i)) == 2: # data='abcdba' data.split(a)===&gt;['','bcdb',''], data.split(b)===&gt;['a','cd','a'] print ('第一个不重复的字符是：&#123;&#125;'.format (i)) breakif __name__ == '__main__': s = input ('请输入随意的字符串：') find_ele (s)]]></content>
      <categories>
        <category>面试笔试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试之接口测试]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[python自动化测试之接口测试1. 项目框架的分层图: 2. 代码2.1 common文件夹2.1.1 do_request.py (发起http请求)12345678910111213141516171819202122232425262728293031import requestsclass HttpRequest: def __init__(self): #保证同一个session,方便下次自动调用 self.session = requests.session() def http_request(self,method,url,data=None,json=None): if type(data)==str: #Excel取出的数据类型是:字符串,但一般传参需要的类型是:字典 data = eval(data) method = method.lower() #强制转换为小写(大写也可以,方便识别) if method == 'get': resp = self.session.request(method=method,url=url,params=data) elif method == 'post': if json: resp = self.session.request(method=method,url=url,json=json) else: resp = self.session.request(method=method,url=url,data=data) else: print('暂不支持其他的请求方法!!') print('请求响应:&#123;&#125;'.format(resp.status_code)) print ('响应文本:&#123;&#125;'.format (resp.text)) print('cookies:&#123;&#125;'.format(resp.cookies)) return respif __name__ == '__main__': # 注册接口 register_url = 'http://test.lemonban.com/futureloan/mvc/api/member/register' params = &#123;'mobilephone': '18871362019', 'pwd': '123456', 'regname': "test"&#125; resp = HttpRequest().http_request('post',url=register_url,data=params) print(resp.text) 2.1.2 do_excel.py (操作Excel的读写)123456789101112131415161718192021222324252627282930313233343536373839404142from openpyxl import load_workbookclass Case: def __init__(self): self.case_id =None self.title = None self.url=None self.data = None self.method = None self.expected = None self.actual = None self.result = Noneclass DoExcel: def __init__(self,file_name,sheet_name): self.file_name = file_name self.sheet_name = sheet_name def get_data(self): #Excel的读取数据操作 wb = load_workbook(self.file_name) sheet = wb[self.sheet_name] # 使用类与对象的思想进行操作 cases=[] for i in range(2,sheet.max_row+1): row_case=Case() #实例化对象 row_case.case_id = sheet.cell(row=i,column=1).value #对象调用属性 row_case.title = sheet.cell (row=i, column=2).value row_case.url = sheet.cell (row=i, column=3).value row_case.data = sheet.cell (row=i, column=4).value row_case.method = sheet.cell (row=i, column=5).value row_case.expected = sheet.cell (row=i, column=6).value cases.append(row_case) wb.close () return cases def write_back(self,row,col,value): #excel的写回操作 wb = load_workbook(self.file_name) sheet = wb[self.sheet_name] sheet.cell(row,col).value = value wb.save(self.file_name) wb.close() 2.1.3 contants.py (文件的路径)1234567891011121314import os# os.path.abspath(__file__) 动态获取当前文件的路径# os.path.dirname(os.path.abspath(__file__)) 动态获取当前文件的上一个文件夹的路径base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) #路径到了interface_test# print(base_dir)# 测试用例 Excel文件case_file = os.path.join(base_dir,'data','cases.xlsx')# print(case_file)# 有关线上环境与测试环境的网址切换的配置文件global_config_file = os.path.join(base_dir,'config','global.cfg')online_config_file = os.path.join(base_dir,'config','online.cfg')test_config_file = os.path.join(base_dir,'config','test.cfg') 2.1.4 config.py(配置文件的读取)1234567891011121314151617181920212223242526272829from configparser import ConfigParserfrom interface_test.common.contants import *class ReadConfig: def __init__(self,encoding='utf-8'): self.cf = ConfigParser() #打开配置文件 self.cf.read(global_config_file,encoding) #先加载global.cfg配置文件 switch = self.cf.getboolean('switch','on') #读取global.cfg配置文件的switch的值 if switch: # on=True 开关打开的时候,加载的是线上环境的配置 self.cf.read(online_config_file,encoding) else: self.cf.read(test_config_file,encoding) def get_strvalue(self,section,option): # 获取字符串 return self.cf.get(section,option) def get_intvalue(self,section,option): # 获取整数 return self.cf.getint(section,option) def get_boolvalue(self,section,option): # 获取布尔值 return self.cf.getboolean(section,option)if __name__ == '__main__': config = ReadConfig() value = config.get_boolvalue('switch','on') # value = config.get_strvalue('api','pre_url') print(value) 2.1.5 do_mysql(操作数据库)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import pymysqlfrom interface_test.common.config import ReadConfigconfig = ReadConfig ()class DoMysql: # 1.建立连接 # 2.新建一个查询界面 # 3.编写sql语句 # 4.执行SQL语句 # 5.查看结果 # 6.关闭查询 # 7.关闭数据库 def __init__(self): # db_host = 'test.lemonban.com' # db_user = 'test' # db_password = 'test' # db_database = 'future' # db_port = 3306 # 读取数据库的配置文件的值（在online.cfg的配置文件中，section：db_test 下的值） db_host = config.get_strvalue('db_test','db_host') db_user = config.get_strvalue('db_test','db_user') db_password = config.get_strvalue('db_test','db_password') db_database = config.get_strvalue('db_test','db_database') db_port = config.get_intvalue('db_test','db_port') self.db = pymysql.connect (host=db_host, user=db_user, password=db_password, database=db_database, port=db_port,charset='utf8') self.cursor= self.db.cursor () # 创建游标 def fetch_one(self,sql): # 查询一条数据 self.cursor.execute(sql) return self.cursor.fetchone() def fetch_all(self,sql): # 查询所有的数据 self.cursor.execute(sql) return self.cursor.fetchall() def close(self): self.cursor.close() # 关闭查询 self.db.close() # 关闭数据库连接if __name__ == '__main__': my_sql = DoMysql () sql = 'select max(mobilephone) from future.member' #获取数据库中最大的手机号 result = my_sql.fetch_one(sql) print(result) 2.1.6 re_context(正则匹配操作) 2.2 config文件夹2.2.1 global.cfg123[switch]on = True;on = False 2.2.2 online.cfg123456789[api]pre_url = http://test.lemonban.com/futureloan/mvc/api[db_test]db_host = test.lemonban.comdb_user = testdb_password = testdb_database = futuredb_port = 3306 2.2.3 test.cfg12[api]pre_url = http://47.107.168.87:8080/futureloan/mvc/api 2.3 data文件夹2.3.1 cases.xlsx 2.4 log文件夹2.4.1 my_log.py 2.5 report文件夹2.5.1 report.html(这是自动生成的) 2.6 testcases文件夹2.6.1 test_register.py123456789101112131415161718192021222324252627282930313233343536373839404142434445import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.do_mysql import DoMysqldo_excel = DoExcel(case_file,'register')register_cases = do_excel.get_data()@ddtclass RegisterTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() cls.mysql = DoMysql () # 创建数据库的连接 @data(*register_cases) def test_register(self,case): if case.data.find('register_mobile')&gt;-1: #测试用例中找到register_mobile sql = 'select max (mobilephone) from future.member' max_phone = self.mysql.fetch_one(sql)[0] # 得到的数据是元组，需要取里面的第一个值（索引） max_phone = int(max_phone)+1 # 将数据库中最大的手机号+1，保证该手机号未被注册 # replace()函数 是替换之后重新返回一个新的字符串，有返回值 需要变量去接收 case.data= case.data.replace('register_mobile',str(max_phone)) # 替换参数值 resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.text) write_result = 'Pass' except AssertionError as e: write_result = 'Failed' print('断言出错:&#123;&#125;'.format(e)) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close() cls.mysql.close()if __name__ == '__main__': unittest.main() 2.6.2 test_login.py2.6.3 test_recharge.py2.6.4 test_withdraw.py2.6.5 test_addloan.py2.6.6 test_audit.py2.6.7 test_bidloan.py2.6.8 run.py]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化</tag>
        <tag>接口测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo与markdown语法简单汇总]]></title>
    <url>%2F2019%2F04%2F09%2Fhexo%E4%B8%8Emarkdown%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8D%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[hexo与markdown语法简单汇总hexo语法 hexo init —&gt;初始化本地文件夹为网站的根目录 hexo new post’博客名’ = hexo new ‘博客名’;简称:hexo n —&gt;新建文字(默认.md) hexo generate —&gt; 生成静态文件;简称:hexo g hexo deploy —&gt; 用于部署网站;简称:hexo d hexo server —&gt; 用于启动本地服务器;简称:hexo s5.1 hexo server -p —&gt;指定服务器端口,默认40005.2 hexo server -i —&gt;指定服务器ip地址,默认0.0.0.05.3 hexo server -s —&gt;静态模式,仅提供 public 文件夹中的文件并禁用文件监视 hexo g -d —&gt;指定生成后部署 hexo clean —&gt;用于清除缓存文件 markdown语法 标题1.1 一级标题—&gt;#1.2 二级标题—&gt;##1.3 三级标题—&gt;###1.4 四级标题—&gt;####1.5 五级标题—&gt;#####1.6 六级标题—&gt;###### 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 字体2.1 加粗—&gt;要加粗的内容2.2 斜体—&gt;要倾斜的内容2.3 斜体加粗—&gt;要斜体加粗的内容2.4 删除线—&gt;需要加删除线的内容 引用语法:&gt;需要引用的文字内容 12&gt; 这是引用的内容&gt;&gt; 这也是引用的内容 分割线-/*三个以上即可 1234-------******** 图片 1234 语法: ![图片alt](图片地址 "图片title")---&gt;title可不加 例如:![古风](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1555065335148&amp;di=e3e3187e01f54cd7bc807b3068230a40&amp;imgtype=0&amp;src=http%3A%2F%2Fp4.gexing.com%2FG1%2FM00%2F3F%2F3D%2FrBACJlTKBjPSVP1XAAEBEKmUep8763.jpg) 超链接 12345语法: [超链接名](超链接地址 "超链接title")--&gt;title可不加例如:[简书](http://jianshu.com)[百度](http://baidu.com) 列表 1234567 7.1 无序列表---&gt;-+*都可以(符号与内容之间都要有一个空格) 7.2 有序列表---&gt;数字加点(数字与内容之间也要有空格) 7.3 列表嵌套---&gt;上一级与下一级之间敲三个空格 * 测试数据 - 测试1 + 测试2 - 测试3 表格 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 代码9.1 单行代码:代码之间分别用一个反引号括起来 单行代码 单行代码内容9.2 多行代码:代码之间分别用三个反引号括起来 123代码内容代码内容代码... 流程图 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;]]></content>
      <categories>
        <category>简单语法汇总</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python自动化测试面试题]]></title>
    <url>%2F2019%2F04%2F04%2Fpython%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常见的python自动化测试的面试题目1. 对函数传参为可变型数据类型 进行改进1234567def add(ele,mylist=[]): mylist.append(ele) return mylist print(add(4))print(add(5))print(add(6)) 运行结果如下图: 解决方法一:(最简单的方法,但是代码有点冗余) 1234567 def add(ele,mylist=[]): mylist.append(ele) return mylistprint(add(4,[]))print(add(5,[]))print(add(6,[])) 解决方法二:(推荐使用) 123456789 def add(ele,mylist=[]): if not mylist: mylist=[] mylist.append(ele) return mylistprint(add(4))print(add(5))print(add(6)) 解决方法三:(将默认参数修改为 不可变的类型) 1234567def add(ele,mylist=None): mylist.append(ele) return mylist print(add(4))print(add(5))print(add(6)) 2. 简述方法中__init__() 与__new__()的区别? 方法__new__()的特性1.1 __new__()用于创建实例,在实例创建之前调用,类级别的方法,是个静态方法1.2 __new__()至少有个参数cls,代表当前类,在实例化时由python解释器自动识别1.3 __new__()必须要返回值,返回实例对象 方法__init__()的特性2.1 __init__()用于初始化实例,在实例对象创建后被调用,对象级别的方法,用于设置对象的一些初始值2.2 __init__()至少有一个参数self,它是new()返回的实例,init()是在new()的基础上完成数据的初始化操作2.3 __init__()不需要返回值 __new__()的作用3.1 __new__() 用来继承一些不可变的class(比如:int,str,tuple)提供一个自定义类的实例化过程的途径 123class 子类名(int): def __new__(cls,value): return super(子类类名,cls).__new__(cls,abs(value)) 3.2 __new__()实现单例模式(每次初始化时只返回一个对象) 1234def __new__(cls): if not hasattr(cls,'instance'): cls.instance = super(子类类名,cls).__new__(cls) return cls.instance]]></content>
      <categories>
        <category>面试笔试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换主题踩得坑]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%B8%A9%E5%BE%97%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1. 使用hexo+github 搭建博客 更换主题 踩到的坑 使用别人的主题 修改theme 部署发布(hexo clean — hexo s) 登录本地服务器 (localhost:4000)界面出现: 解决方案:npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive(安装 Apollo Github 的依赖包) 本地就可以正常运行安装后,hexo clean —&gt;hexo s 部署到github上运行:安装后,hexo clean —&gt;hexo g—&gt;hexo d 本地样式正常,但是部署到github上 远程访问 样式发生改变(样式乱)原因: 修改根目录下的配置文件: _config.yml 将url进行修改 root 不需要修改 由于参考过网上: 将root由/—&gt;改为/你的项目名 但是经过测试,没有起到作用,可能因人而异吧 配置修改如下图:]]></content>
      <categories>
        <category>更换主题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
