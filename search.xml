<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python之类与对象]]></title>
    <url>%2F2019%2F05%2F21%2Fpython%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[python面向对象编程之类与对象 类的语法：class 类名: 类的解释文档 类方法(功能)，类属性(特征) def 方法名(self): pass 类名的规范：标识符 数字 字母 下划线组成 不能以数字开头 见名之意,不能使用关键字 驼峰命名： 每个单词首字母大写 万物皆对象（对象都是来自(属于)某一个类）–》类可以产生对象 创建对象：类名() —&gt; 类名+括号() 对象具有类的所有的属性和方法 。 调用：对象.属性 对象.方法 类的方法：对象方法，静态方法，类方法 在类外面：类里面的属性与方法 ：该类实例化的对象可以调用 对象方法：def 方法名(self): self–&gt; 调用这个方法的对象本身只能用对象来调用 (类不可以调用对象方法) 类方法：@classmethod def 方法名(cls)： cls表示类本身，调用该方法的时候，会将类作为参数传进来类可以调用，对象也可以调用 用@classmethod来装饰 静态方法：@static def 方法名()类可以调用，对象也可以调用 用@static来装饰如果有这样的一个方法，它跟类里面的属性，方法，没有任何关联的时候，用不到类里面的属性，方法，就使用静态方法]]></content>
      <categories>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python断言方法]]></title>
    <url>%2F2019%2F05%2F20%2Fpython%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[python 之常用的断言方法Assert 断言：是在执行自动化脚本中，判断测试用例的测试结果的过程使用的方法 基本的断言方法提供了测试结果是True还是False。所有的断言方法都有一个msg参数，如果指定msg参数的值，则将该信息作为失败的错误信息返回 在unittest包里面看到的比较全的断言：]]></content>
      <categories>
        <category>python之断言方法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>断言方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL数据库操作之简单操作命令]]></title>
    <url>%2F2019%2F05%2F20%2FSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[MySQL数据库操作的命令之简单语法汇总SQL由两部分组成：数据操作语言(DML),数据定义语言(DDL)DML: select (查询) update (更新) delete (删除) insert into (插入) DDL: create database (新建数据库) alter database (修改数据库) create table (新建表) alter table (修改表) drop table (删除表) create index (创建索引) drop index (删除索引) 语法分析： select语法 select 列表名 from 表名 从数据库中查询某一列的值 (select * from 表名) 从数据库中查询所有 select distinct 列表名 from 表名 关键词 DISTINCT 用于返回唯一不同的值(去掉重复的值) select 列表名 from 表名 where 列表名 运算符 值 (值为字符，用单双引号都可以，值为数值，不需要引号) select 列表名 from 表名 where 列表名 运算符 值 and/or 列表名 运算符 值 运算符 and or (and 全真为真 or 全假为假) and: 若第一个条件和第二个条件都成立，则and运算符显示一条记录 or: 若多个条件中只要有一个条件成立，则or运算符显示一条记录 select 列表名 from 表名 order by 列表名 select 列表名 from 表名 order by 列表名 DESC order by 语句根据指定的列 对结果进行排序（默认升序排序 ASC）,降序排序 使用关键字DESC insert into 语法 insert into 表名 values (值1,值2,…..) 向表中插入新的行(值全部要根据列 完整填写) insert into 表名(列1,列2,…)values(值1,值2,….) 指定要插入数据的列 update语法 update 表名 set 列名 = 新值 where 列名 = 某值 (修改表中的某一列的数据) update 表名 set 列名1 = 新值,列名2 = 新值,… where 列名 = 某一值 (更新某一行中的若干列数据) delete语法 delete from 表名 where 列名 = 值 (删除某一行) delete from 表名 / delete * from 表名 (删除所有行) like 操作符语法 select * from 表名 where 列名 like ‘’(模式 也就是 通配符) in 操作符语法 select 列名 from 表名 where 列名 in (value1,value2,….) 筛选列名值存在value值中的数据 between操作符语法 select * from 表名 where 列名 between value1 and value2 BETWEEN … AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。(部分会包括临界值) Alias 操作符语法（别名） select 列名 from 表名 AS 表别名 (指定表的别名) select 列名 AS 列别名 from 表名 (指定列的列名) 使用 SQL，可以为列名称和表名称指定别名（Alias) Join 联表查询 join: 如果表中有至少一个匹配，则返回1行 (加上ON) left join :即使右表中没有匹配，也从左表返回所有的行 right join : 即使左表中没有匹配，也从右表返回所有的行 full join : 只要其中一个表存在匹配，就返回行 (也称full outer join 外连接) inner join : 内连接 (inner join 表2 ON) select * from 表1,表2 where 表1.主键 = 表2.key(表1的主键作为表2的外键 值是一样的) select * from 表1 inner join 表2 ON 表1.主键 = 表2.key SELECT 列名s FROM 表1 INNER JOIN 表2 ON表.列名=表2.列名 SELECT 列名s FROM 表1 left join 表2 ON表.列名=表2.列名 SELECT 列名s FROM 表1 right join 表2 ON表.列名=表2.列名 SELECT 列名s FROM 表1 full join 表2 ON表.列名=表2.列名 union 操作符语法 UNION 操作符用于合并两个或多个 SELECT 语句的结果集 UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 select 列名s from 表1 union select 列名s from 表2 UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名 UNION 命令只会选取不同的值(若两个表中有相同的数值，只取一个 不会全部显示) UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。(相同的数值也会打印出来) create database 语法 create database name (创建数据库) create table CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,….) 用于创建数据库中的表 SQL约束 not null 强制列不接受 NULL 值 (如果不向字段添加值，就无法插入新记录或者更新记录) union 约束唯一标识数据库表中的每条记录 最后加上UNIQUE (列名) primary key 主键 主键必须包含唯一的值，主键列不能包含 NULL 值，每个表都应该有一个主键，并且每个表只能有一个主键。 foreign key check default 请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束（CONSTRAINT 取名 UNIQUE (列名1,列名2)） 当表已被创建时，如需在 “某一” 列创建 UNIQUE 约束 (ALTER TABLE 表名 ADD UNIQUE (Id_P)) 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束 (ALTER TABLE 表名 ADD CONSTRAINT 取名 UNIQUE (列名1,列名2)) 撤销 UNIQUE 约束 (ALTER TABLE 表名 DROP INDEX 取名) MySQL数据类型 文本–》text类型 数字–》number类型 时间–》date类型 SQL函数 合计函数—aggregate函数 纯量函数—scalar函数 运算符与通配符 操作符 描述 通配符 描述 = 等于 % 替代一个或多个字符 &lt;&gt; 不等于(!=) _ 仅替代一个字符 &gt; 大于 [charlist] 字符列中的任何单一字符 (like ‘[ALN]%’ 表示匹配以A L N来头的数据 ) &lt; 小于 [^charlist] 不在字符列中的任何单一字符 &gt;= 大于等于 [!charlist] 不在字符列中的任何单一字符 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 需要注意的点 group by 与 where 一起使用时候： where 一定在 group by 之前 having 只能在 group by 后面，对分组后的结果进行筛选 (使用having的前提条件： 分组) where 后的表达式 不允许使用 聚合函数 having 可以使用聚合函数 where group by having order by 执行顺序 order by 默认升序排序，后面必须是要排序的列名，也可以多个列名 group by 分组 必须有聚合函数（sum(),count(),avg()）配合使用]]></content>
      <categories>
        <category>数据库操作语法</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口自动化面试题]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[自动化测试之接口面试题题目汇集： json和字典的区别？ -对基础数据类型的考察 测试的数据你放在哪？ -数据与脚本分离 参数化 - 数据驱动模式 下个接口请求参数依赖上个接口的返回数据 - 参数关联 依赖于登录的接口如何处理 -token和session的管理 依赖第三方的接口如何处理 -mock模拟数据返回 不可逆的操作，如何处理，比如删除一个订单这种接口如何测试 -造数据 接口产生的垃圾数据如何清理 - 数据清理 一个订单的几种状态如何全部测到，如：未处理，处理中，处理失败，处理成功 - 造数据，改数据库订单状态 python如何连接数据库操作？-数据库的连接操作 其它的就是运行出报告、代码管理（git）、运行策略和持续集成jenkins相关了 题目解答： json和字典的区别？json() 本质是字符串 str类型,是一种按照key:value键值对格式的字符串字典：是python语言中的一种数据类型(int str,float,bool,dict,tuple,list) 测试的数据你放在哪？1对于账号密码，这种管全局的参数，可以用命令行参数，单独抽出来，写的配置文件里（如ini）2对于一些一次性消耗的数据，比如注册，每次注册不一样的数，可以用随机函数生成3.对于一个接口有多组测试的参数，可以参数化，数据放yaml,text,json,excel都可以4.对于可以反复使用的数据，比如订单的各种状态需要造数据的情况，可以放到数据库，每次数据初始化，用完后再清理5.对于邮箱配置的一些参数，可以用ini配置文件6.对于全部是独立的接口项目，可以用数据驱动方式，用excel/csv管理测试的接口数据7.对于少量的静态数据，比如一个接口的测试数据，也就2-3组，可以写到py脚本的开头，十年八年都不会变更的总之不同的测试数据，可以用不同的文件管理 什么是数据驱动，如何做参数化?使用装饰器，ddt,data,unpack ddt装饰测试类，data装饰测试方法，unpack 拆包，将需要修改的数据进行参数化，方便后期数据的操作参数化的思想是代码用例写好了后，不需要改代码，只需维护测试数据就可以了，并且根据不同的测试数据生成多个用例 下个接口请求参数依赖上个接口的返回数据？1.不同的接口封装成不同的函数或方法，需要的数据return出来，用一中间变量a去接受，后面的接口传a就可以了2.使用反射机制，将上一个接口返回的数据 作为一个入参 传到下一个接口中。setattr,将返回的数据存到一个变量中 依赖于登录的接口如何处理？1.登录接口依赖token的，可以先登录后，token存到一个yaml或者json，或者ini的配置文件里面，后面所有的请求去拿这个数据就可以全局使用了2.如果是cookies的参数，可以用session自动关联 s=requires.session() 然后根据get/post方法，进行调用（s.get()）自动关联session 依赖第三方的接口如何处理?使用mock机制,去搭建一个mock服务，模拟接口返回数据 不可逆的操作，如何处理，比如删除一个订单这种接口如何测试?考查造数据的能力，接口的请求数据，很多都是需要依赖前面一个状态的。比如工作流这种，流向不同的人状态不一样，操作权限不一样，测试的时候，每种状态都要测到,就需要自己会造数据了。平常手工测试造数据，直接在数据库改字段状态。那么自动化也是一样，造数据可以用python连数据库了，做增删改查的操作测试用例前置操作，setUp做数据准备后置操作，tearDown做数据清理 接口产生的垃圾数据如何清理？造数据和数据清理，需用python连数据库了，做增删改查的操作测试用例前置操作，setUp做数据准备后置操作，tearDown做数据清理 一个订单的几种状态如何全部测到，如：未处理，处理中，处理失败，处理成功创造数据，修改数据的类型 python如何连接数据库操作？import pymysql(根据公司的数据库的类型进行连接) db=pymysql.connect(user=’’,password=’’,host=’’,db_name=’’,port=’’)使用cursor()方法获取操作游标 cursor=db.cursor() SQL 查询语句:sql=’’ 执行SQL语句：cursor.execute(sql) 获取结果：result=cursor.fetchone()cursor.close() db.close()1.新建连接，数据库的连接信息2.新建查询界面3.编写SQL语句4.执行SQL语句5.查看结果6.关闭查询7.关闭数据库的连接 git 将代码上传到github上 git add –all git commit ‘注释’ git pushgit 将github上的代码拉下来 git clone ‘github的项目地址’jenkin持续集成，发生邮件等]]></content>
      <categories>
        <category>接口面试题</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试框架的知识梳理]]></title>
    <url>%2F2019%2F05%2F17%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%9A%84%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[自动化测试框架的知识梳理 框架的意义：可读性，可维护性，可扩展性 维护与代码分离：使用数据驱动(ddt) 结构分层：数据层(testcase文件夹)，用例层(data文件夹)，逻辑层(common文件夹) 测试的步骤： 准备测试数据：设计excel，excel数据的读写，参数化替换 发起请求：判断请求的方式，请求的url(url的拼接)，参数转为字典（case.data）eval()，拿到返回结果 解析结果：断言，响应码，响应结果，响应文本，回写测试结果到Excel 框架的好处： 手工测试用例与自动用例完美结合，避免重复工作 配置灵活，根据需要快速选择执行用例/切换测试环境(不同的环境，测试环境，线上环境，设置一个总开关，决定使用的环境) 常用功能封装，逻辑清楚，易于维护(结构分层) 统一执行入口，管理测试用例集(run.py入口，生成测试报告 ) 持续集成，定时构建，快速反馈(jenkins) 代码上传到git上，持续集成到jenkins上，发邮件快速反馈结果 项目使用到的技术与框架： 语言：python(语言简洁) 测试框架：unittest 接口调用：requests(API 非常简洁) 数据驱动：ddt(装饰器：ddt(装饰测试类),data(装饰测试方法),unpack()) 数据管理：openpyxl(可以同时支持读与写) excel 写测试用例(exel,csv,json,yaml,txt) 数据库-&gt;数据数量很大的时候 数据库交互：pymysql(数据库：MySql) 数据格式的转换：eval(), json.loads() Excel读取出来的数据都是 str ，request方法的参数要求是：dict 日志处理：logging 清晰的了解执行的过程，快速定位问题(创建日志收集器) 持续集成：jenkins 解决重复发版本带来的重复工作 （配置git-》拉代码-》run-&gt;发邮件）]]></content>
      <categories>
        <category>自动化测试框架</category>
      </categories>
      <tags>
        <tag>自动化测试，框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试编程题]]></title>
    <url>%2F2019%2F05%2F17%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[python自动化测试面试—编程题 搜索引擎中会对用户输入的数据进行处理，第一步就是词法分析，分离字符串中的数字、中文、拼音、符号。比如这个字符串：我的是名字是ths,今年18岁语法分析后得到结果如下： 请编写程序实现该词法分析功能。数字：18中文：我的名字是 今年 岁拼音：ths符号：，。 1234567891011121314151617181920212223242526方法一：使用string 模块import stringnumber=[]chinese = []english=[]symbol=[]def find_data(s):for i in s: if i in string.digits: number.append(i) elif i in string.ascii_letters: english.append(i) elif i in string.punctuation: symbol.append(i) elif i in string.whitespace: symbol.append(i) else: chinese.append(i)print('数字是：&#123;&#125;'.format(''.join(number)))print('中文是：&#123;&#125;'.format(''.join(chinese)))print('字母是：&#123;&#125;'.format(''.join(english)))print('符号是：&#123;&#125;'.format(''.join(symbol)))if __name__ == '__main__':in_data = input('请输入你要解析的字符串：')find_data(in_data) 12345678910111213141516方法二：使用正则方法import redef find_data_re(s):patter = &#123;"数字":"\d","字母":"[a-zA-Z]","汉字":"[\u4e00-\u9fff]"&#125;for k,v in patter.items(): # print('键的内容：&#123;&#125;'.format(k)) # print ('值的内容：&#123;&#125;'.format (v)) # 取字典中的value值 result = re.findall(v,s) print(k+':'+''.join(result)) s = re.sub(v,'',s)print('符号：&#123;&#125;'.format(s))if __name__ == '__main__':in_data = input('请输入你要解析的字符串：')find_data_re(in_data) 编写程序实现:根据输入的数字打印菱形 12345678910111213141516171819202122232425262728293031323334353637383940n=5，输出： * ******** *** *n=6，输出： * ************* *** *n为任意大于1的正整数# 理解题意# 1.行数=输入的数 n=5-&gt;有5行# 2.*的个数 2n-1 n=1 第一行 2*1-1=1 第一行一个*# 3.星号+空格=输入的数字n# 4.前面的空格数 = 后面的空格数 = （n-星号数）/2 = 单边空格个数 (n=输入的数)def print_star(n): # 前半部分 for i in range(1,n+1,2): # 步调为 2 第一行1 第二行3 star_num = ' '*((n-i)//2)+'*'*i # ' '*((n-i)//2) 前面的空格数目 print(star_num) if n%2 == 0: # n为偶数 s = n-1 # n=6 那么下部分第一行只打印5个，所以打印 n-1 else: # n 为奇数 s = n-2 # 比如n=5,那么下半部份，第一行只打印3个 所以打印n-2 # 后半部分 for i in range(s,0,-2): star_num = ' ' * ((n - i) // 2) + '*' * i print(star_num)if __name__ == '__main__': print_star(5) 传入一个Json串，返回一个字典，字典只取出Json最底层的数据，中间如果有字符串也要进行处理，请以下面的数据为例，请用递归方法实现Json：{“a”:”aa”,”b”:[‘{“c”:”cc”,”d”:”dd”}’,{“f”:{“e”:”ee”}}]}输出：Dic:{‘a’:’aa’,’c’:’cc’,’d’:’dd’,’e’:’ee’} 1234567891011121314151617181920212223def str_to_dict(S): # S 是一个json字符串 dict_result=&#123;&#125; if type(S)== str: # S 是字符串 直接处理字符串 S = eval(S) # （字符串转为字典 不传给dict_result(因为字典里面还有其他的数据类型)） print('eval()后的S的值：&#123;&#125;,类型是：&#123;&#125;'.format(S,type(S))) if type (S) == list: # 判断是否是列表，遍历列表里面的内容 for i in S: d = str_to_dict(i) dict_result.update(d) if type(S)==dict: # 判断是否是字典 for k,v in S.items(): if type(v)==list or type(v)==dict: # 字典里面镶嵌着列表或者字典 d= str_to_dict(v) # （字典里面有列表和字典里面有字典） dict_result.update(d) else: dict_result[k]=v # 单纯是字典，就直接存在dict_result字典中 return dict_result # 返回底层字典 if __name__ == '__main__': J='&#123;"a":"aa","b":[\'&#123;"c":"cc","d":"dd"&#125;\',&#123;"f":&#123;"e":"ee"&#125;&#125;]&#125;' dict = str_to_dict(J) print(dict)]]></content>
      <categories>
        <category>自动化面试编程题</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins部署python项目踩得坑]]></title>
    <url>%2F2019%2F05%2F10%2Fjenkins%E9%83%A8%E7%BD%B2python%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%BE%97%E5%9D%91%2F</url>
    <content type="text"><![CDATA[jenkins部署python项目踩的坑项目：webservice项目部署到jenkins中，需要安装python项目中所需要的依赖环境在项目中 生成所有需要依赖的库 pip freeze &gt; requirements.txt在新的环境中 ，将所有的依赖包全部下载下来 pip install -r requirements.txt问题：pip不是内部或外部命令，也不是可运行的程序或批处理文件 步骤： jenkins配置 修改配置方式 保存后，点击立即构建 出现上述问题 检查pip或python是否配置环境变量 排除pip或者python未配置环境变量的问题，依旧无法解决上述问题 解决方案： win+r 进入终端窗口 进入该项目从github上pull下来的代码的路径 输入命令：pip install -r requirements.txt 输入命令：python run.py 发现终端运行是成功的，但是一样的路径，jenkins 构建 输入Windows批处理命令，运行出错，报pip出错 一直很奇怪这个问题，百度好久都没有找到解决方案 再次去查看 依赖包安装成功后的路径 发现suds模块安装到其他目录去了，没有按照到python目录下 将生产suds模块的文件夹找到，然后删除 重新安装 pip install -r requirements.txt 重新运行 jenkins运行成功 pip不是内部或外部命令，也不是可运行的程序或批处理文件 该问题完美解决（主要是第一次安装环境的时候，安装目录出错了）]]></content>
      <categories>
        <category>jenkins部署项目</category>
      </categories>
      <tags>
        <tag>jenkins构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重要网址记录大全]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%87%8D%E8%A6%81%E7%BD%91%E5%9D%80%E8%AE%B0%E5%BD%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[重要网址记录大全jenkins官网jenkins：https://jenkins.io/download/外文网（世界级）：https://www.edx.org慕课网：http://www.imooc.com/course/listw3school（在线编程基础知识）：http://www.w3cschool.cn/tutorial慕课学院：http://mooc.guokr.com/course/?dept_id=52&amp;order=hot学堂在线：http://www.xuetangx.com/LeetCode Online Judge(英文网，在线编程答疑)：https://leetcode.com/mooc中国：http://www.mooc.cn/]]></content>
      <categories>
        <category>网址记录</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins安装]]></title>
    <url>%2F2019%2F04%2F24%2Fjenkins%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[python自动化面试一]]></title>
    <url>%2F2019%2F04%2F22%2Fpython%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E4%B8%80%2F</url>
    <content type="text"><![CDATA[常见的python自动化测试的面试题目1. 给定一个只包含正整数的非空数组,返回该数组中重复次数最多的前N个数字,返回的结果按重复次数从多到少降序排列(N不存在取值非法的情况) 12345678910111213141516方法一：def ele_sort(data,n): d=&#123;&#125; for i in data: d[i]=data.count(i) #将元素出现的次数 作为字典键值对的value值，组成（i:d[i]==&gt;元素：元素出现的次数） print(d.items()) #type(d.items())--&gt;&lt;class 'dict_items'&gt; sort_data = sorted(d.items(),key=lambda item:item[1],reverse=True) for i in range(0,n): print('排名第&#123;&#125;的元素：&#123;&#125;，出现了&#123;&#125;次'.format(i+1,sort_data[i][0],sort_data[i][1]))if __name__ == '__main__': l = [3, 4, 5, 3, 2, 5, 6, 2, 8, 9, 2, 4, 2, 5, 6, 3, 2, 4, 5, 5, 3, 2, 1, 5, 6, 5] n = int(input('请输入小于元素个数的正整数：')) ele_sort(l,n) 方法二：（使用set集合操作） 12345678910111213141516def data_sort(data,n): data_new = set(data) #将重复的数据去掉 d=&#123;&#125; for i in data_new: d[i]=data.count(i) print(d.items()) list_data = sorted(d.items(),key=lambda item:item[1],reverse=True) for i in range(0,n): print('排名第&#123;&#125;的元素：&#123;&#125;，出现&#123;&#125;次'.format(i+1,list_data[i][0],list_data[i][1]))if __name__ == '__main__': l = [3, 4, 5, 3, 2, 5, 6, 2, 8, 9, 2, 4, 2, 5, 6, 3, 2, 4, 5, 5, 3, 2, 1, 5, 6, 5] n=int(input('请输入小于元素个数&#123;&#125;的正整数：'.format(len(set(l))))) data_sort(l,n) 代码难点解读:123456789d.items()： 1. 它的数据类型是：dict_items 以列表返回可遍历的(键, 值) 元组数组 2. 注意：返回不是列表：是一个存放多个元祖的高仿列表，[(key,value),(key,value),(key,value)...] 3. 不能用下标，可用for循环sorted(d.items(),key=lambda item:item[1],reverse=True) 1. sorted(iterable,key,reverse)函数,参数key来决定我们根据那个字段对列表元素进行排序, 2. sorted(iterable，key，reverse)函数返回一个新列表，其中包含按升序排列的iterable中的所有项 3. key=lambda 元素: 元素[字段索引] 4. lambda item:item[1] 表示对元素第二个字段(就是 value)进行排序 2. 从字符串‘abcdba‘中找出第一个不重复的字符，方法不限方法一： 使用count()函数 （查看元素在数据中出现的次数）1234567891011def find_ele(data): for i in data: if data.count(i)==1: #元素在数据data出现的次数 print('第一个不重复的字符是：&#123;&#125;'.format(i)) breakif __name__ == '__main__': s= input('请输入随意的字符串：') find_ele(s) 方法二： 使用split()切割函数(切割后 长度为2 说明该元素只存在一个)1234567891011def find_ele(data): for i in data: if len (data.split (i)) == 2: # data='abcdba' data.split(a)===&gt;['','bcdb',''], data.split(b)===&gt;['a','cd','a'] print ('第一个不重复的字符是：&#123;&#125;'.format (i)) breakif __name__ == '__main__': s = input ('请输入随意的字符串：') find_ele (s)]]></content>
      <categories>
        <category>面试笔试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试之接口测试]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[python自动化测试之接口测试1. 项目框架的分层图: 2.1 common文件夹2.1.1 do_request.py (发起http请求)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import requestsfrom interface_test.common.config import ReadConfigconfig = ReadConfig()class HttpRequest: ''' 公共使用一个session, cookies自动传递 这是一个操作http请求的类,使用这类的request方法去完成不同的HTTP请求，并且返回响应结果 ''' def __init__(self): #保证同一个session对象,便于cookies的自动传值 self.session = requests.session() def http_request(self,method,url,data=None,json=None): ''' :param method: 请求的方法 :param url: 请求的路径 :param data: 请求的数据 :param json: json类型的数据 :return: 返回请求响应的文本 ''' method = method.lower() #强制转化为小写 方便后期操作（大写也可以） if type(data)==str: # 将字符串转化为 字典形式的数据 data = eval(data) # 路径的拼接，根据线上环境或测试环境 进行路径的拼接 url = config.get_strvalue('api','pre_url')+url print('data的数据&#123;&#125;：'.format(data)) print('url的路径：',url) if method == 'get': resp = self.session.request(method=method,url=url,params=data) elif method == 'post': if json: resp = self.session.request(method=method,url=url,json=json) else: resp = self.session.request(method=method,url=url,data=data) else: print('暂不支持其他的请求方式!') print ('响应码:', resp.status_code) print ('响应文本:', resp.text) print ('响应的cookie:', resp.cookies) return resp def close(self): self.session.close()if __name__ == '__main__': # 注册接口 register_url = 'http://test.lemonban.com/futureloan/mvc/api/member/register' params = &#123;'mobilephone': '18871362019', 'pwd': '123456', 'regname': "test"&#125; resp = HttpRequest().http_request('post',url=register_url,data=params) print(resp.text) 2.1.2 do_excel.py (操作Excel的读写)123456789101112131415161718192021222324252627282930313233343536373839404142from openpyxl import load_workbookclass Case: def __init__(self): self.case_id =None self.title = None self.url=None self.data = None self.method = None self.expected = None self.actual = None self.result = Noneclass DoExcel: def __init__(self,file_name,sheet_name): self.file_name = file_name self.sheet_name = sheet_name def get_data(self): #Excel的读取数据操作 wb = load_workbook(self.file_name) sheet = wb[self.sheet_name] # 使用类与对象的思想进行操作 cases=[] for i in range(2,sheet.max_row+1): row_case=Case() #实例化对象 row_case.case_id = sheet.cell(row=i,column=1).value #对象调用属性 row_case.title = sheet.cell (row=i, column=2).value row_case.url = sheet.cell (row=i, column=3).value row_case.data = sheet.cell (row=i, column=4).value row_case.method = sheet.cell (row=i, column=5).value row_case.expected = sheet.cell (row=i, column=6).value cases.append(row_case) wb.close () return cases def write_back(self,row,col,value): #excel的写回操作 wb = load_workbook(self.file_name) sheet = wb[self.sheet_name] sheet.cell(row,col).value = value wb.save(self.file_name) wb.close() 2.1.3 contants.py (文件的路径)1234567891011121314import os# os.path.abspath(__file__) 动态获取当前文件的路径# os.path.dirname(os.path.abspath(__file__)) 动态获取当前文件的上一个文件夹的路径base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) #路径到了interface_test# print(base_dir)# 测试用例 Excel文件case_file = os.path.join(base_dir,'data','cases.xlsx')# print(case_file)# 有关线上环境与测试环境的网址切换的配置文件global_config_file = os.path.join(base_dir,'config','global.cfg')online_config_file = os.path.join(base_dir,'config','online.cfg')test_config_file = os.path.join(base_dir,'config','test.cfg') 2.1.4 config.py(配置文件的读取)1234567891011121314151617181920212223242526272829from configparser import ConfigParserfrom interface_test.common.contants import *class ReadConfig: def __init__(self,encoding='utf-8'): self.cf = ConfigParser() #打开配置文件 self.cf.read(global_config_file,encoding) #先加载global.cfg配置文件 switch = self.cf.getboolean('switch','on') #读取global.cfg配置文件的switch的值 if switch: # on=True 开关打开的时候,加载的是线上环境的配置 self.cf.read(online_config_file,encoding) else: self.cf.read(test_config_file,encoding) def get_strvalue(self,section,option): # 获取字符串 return self.cf.get(section,option) def get_intvalue(self,section,option): # 获取整数 return self.cf.getint(section,option) def get_boolvalue(self,section,option): # 获取布尔值 return self.cf.getboolean(section,option)if __name__ == '__main__': config = ReadConfig() value = config.get_boolvalue('switch','on') # value = config.get_strvalue('api','pre_url') print(value) 2.1.5 do_mysql(操作数据库)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import pymysqlfrom interface_test.common.config import ReadConfigconfig = ReadConfig ()class DoMysql: # 1.建立连接 # 2.新建一个查询界面 # 3.编写sql语句 # 4.执行SQL语句 # 5.查看结果 # 6.关闭查询 # 7.关闭数据库 def __init__(self): # db_host = 'test.lemonban.com' # db_user = 'test' # db_password = 'test' # db_database = 'future' # db_port = 3306 # 读取数据库的配置文件的值（在online.cfg的配置文件中，section：db_test 下的值） db_host = config.get_strvalue('db_test','db_host') db_user = config.get_strvalue('db_test','db_user') db_password = config.get_strvalue('db_test','db_password') db_database = config.get_strvalue('db_test','db_database') db_port = config.get_intvalue('db_test','db_port') self.db = pymysql.connect (host=db_host, user=db_user, password=db_password, database=db_database, port=db_port,charset='utf8') self.cursor= self.db.cursor () # 创建游标 def fetch_one(self,sql): # 查询一条数据 self.cursor.execute(sql) return self.cursor.fetchone() def fetch_all(self,sql): # 查询所有的数据 self.cursor.execute(sql) return self.cursor.fetchall() def close(self): self.cursor.close() # 关闭查询 self.db.close() # 关闭数据库连接if __name__ == '__main__': my_sql = DoMysql () sql = 'select max(mobilephone) from future.member' #获取数据库中最大的手机号 result = my_sql.fetch_one(sql) print(result) 2.1.6 re_context(正则匹配操作)123456789101112131415161718import refrom interface_test.common.config import ReadConfigconfig = ReadConfig()def replace_data(data): # 1.正则表达式 regular = '#(.*?)#' # 2.查找要匹配的字符串 # search() 扫描字符串，寻找与模式匹配的字符串,返回匹配对象，如果没有找到匹配，则为None while re.search(regular,data): # 找到匹配的对象 find_data = re.search (regular, data) find_key = find_data.group(1) # 拿到参数化的KEY find_value = config.get_strvalue('data',find_key) #拿配置文件里面的值 # sub(pattern, repl, string, count=0, flags=0)有返回值 # pattern正则表达式 repl要替换的数据 string--》data count 替换的次数 data = re.sub(regular,find_value,data,count=1) return data 2.2 config文件夹 （配置文件的操作）2.2.1 global.cfg（控制线上环境或者测试环境的开关）123[switch]on = True;on = False 2.2.2 online.cfg（线上环境）123456789[api]pre_url = http://test.lemonban.com/futureloan/mvc/api[db_test]db_host = test.lemonban.comdb_user = testdb_password = testdb_database = futuredb_port = 3306 2.2.3 test.cfg（测试环境）12[api]pre_url = http://47.107.168.87:8080/futureloan/mvc/api 2.3 data文件夹（存放测试用例的Excel文件）2.3.1 cases.xlsx （测试用例） 注册用例 登录用例 2.4 log文件夹（日志记录文件）2.4.1 my_log.py（日志操作）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import loggingclass MyLog: '''这是一个记录log日志的类''' def my_log(self,level,msg): ''' :param level: 日志的等级 :param msg: 需要输出的提示信息 :return: ''' # 收集器 - --创建一个日志收集器, getLogger()函数 my_logger = logging.getLogger('test_request') my_logger.setLevel('DEBUG') #设置等级 #设定日志输出格式 formatter = logging.Formatter ('%(asctime)s-' '[%(levelname)s]-' '[line:%(lineno)d]-''[日志信息]:%(message)s') #设定输出渠道---&gt;控制台 sh = logging.StreamHandler() sh.setLevel('ERROR') sh.setFormatter(formatter) #设定输出渠道----&gt;指定文件 fh = logging.FileHandler('test.log',encoding='utf-8') fh.setLevel('INFO') fh.setFormatter(formatter) #日志收集器与输出渠道进行对接 my_logger.addHandler (sh) my_logger.addHandler(fh) if level == 'DEBUG': my_logger.debug(msg) elif level=='INFO': my_logger.info(msg) elif level == 'WARNING': my_logger.warning(msg) elif level =='ERROR': my_logger.error(msg) else: my_logger.critical(msg) # 去掉日志的重复 每次收集完毕之后 移除掉日志收集器 my_logger.removeHandler(sh) my_logger.removeHandler(fh) #重新封装五个不同等级的日志级别的函数 def debug(self,msg): self.my_log('DEBUG',msg) def info(self,msg): self.my_log('INFO',msg) def warning(self,msg): self.my_log('WARNING',msg) def error(self,msg): self.my_log('ERROR',msg) def critical(self,msg): self.my_log('CRITICAL',msg)if __name__ == '__main__': log = MyLog() log.debug('这是个调试的信息') 2.5 report文件夹 （测试报告）2.5.1 report.html(这是自动生成的) 2.6 testcases文件夹（存放测试用例的方法）2.6.1 test_register.py（测试注册接口）123456789101112131415161718192021222324252627282930313233343536373839404142434445import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.do_mysql import DoMysqldo_excel = DoExcel(case_file,'register')register_cases = do_excel.get_data()@ddtclass RegisterTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() cls.mysql = DoMysql () # 创建数据库的连接 @data(*register_cases) def test_register(self,case): if case.data.find('register_mobile')&gt;-1: #测试用例中找到register_mobile sql = 'select max (mobilephone) from future.member' max_phone = self.mysql.fetch_one(sql)[0] # 得到的数据是元组，需要取里面的第一个值（索引） max_phone = int(max_phone)+1 # 将数据库中最大的手机号+1，保证该手机号未被注册 # replace()函数 是替换之后重新返回一个新的字符串，有返回值 需要变量去接收 case.data= case.data.replace('register_mobile',str(max_phone)) # 替换参数值 resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.text) write_result = 'Pass' except AssertionError as e: write_result = 'Failed' print('断言出错:&#123;&#125;'.format(e)) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close() cls.mysql.close()if __name__ == '__main__': unittest.main() 2.6.2 test_login.py（测试登录接口）1234567891011121314151617181920212223242526272829303132333435363738import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.re_context import replace_datado_excel = DoExcel (case_file, 'login')login_cases = do_excel.get_data ()@ddtclass LoginTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest () @data(*login_cases) def test_login(self,case): case.data = replace_data(case.data) #参数化 正则匹配解析 resp =self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.json()['msg']) write_result = 'Pass' except AssertionError as e: write_result = 'Failed' print('断言错误：&#123;&#125;'.format(e)) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close()if __name__ == '__main__': unittest.main() 2.6.3 test_recharge.py（测试充值接口）123456789101112131415161718192021222324252627282930313233343536373839import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.re_context import replace_datado_excel = DoExcel (case_file, 'recharge')withdraw_cases = do_excel.get_data ()@ddtclass WithdrawTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() @data(*withdraw_cases) def test_withdraw(self,case): case.data = replace_data(case.data) #参数化 正则匹配解析 resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.json()['msg']) write_result = 'Pass' except AssertionError as e: write_result='Failed' print('断言出错：',e) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close()if __name__ == '__main__': unittest.main() 2.6.4 test_withdraw.py（测试取现的接口）123456789101112131415161718192021222324252627282930313233343536373839import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.re_context import replace_datado_excel = DoExcel (case_file, 'withdraw')withdraw_cases = do_excel.get_data ()@ddtclass WithdrawTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() @data(*withdraw_cases) def test_withdraw(self,case): case.data = replace_data(case.data) #参数化 正则匹配解析 resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.json()['msg']) write_result = 'Pass' except AssertionError as e: write_result='Failed' print('断言出错：',e) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close()if __name__ == '__main__': unittest.main() 2.6.5 test_addloan.py（测试添加标的接口）12345678910111213141516171819202122232425262728293031323334353637383940import unittestfrom ddt import ddt,datafrom interface_practice.common.do_request import HttpRequestfrom interface_practice.common.do_excel import DoExcelfrom interface_practice.common.contants import *from interface_test.common.re_context import replace_datado_excel = DoExcel(case_file,'add_loan')addloan_cases = do_excel.get_data()@ddtclass AddloanTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() @data(*addloan_cases) def test_addloan(self,case): # print('转换前的数据：',case.data) #&#123;"mobilephone": "#normal_user#", "pwd": "#normal_pwd#"&#125; case.data = replace_data(case.data) # print('转换后的数据：',case.data) #&#123;"mobilephone": "17786426991", "pwd": "123456"&#125; resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.json()['msg']) write_result = "Pass" except AssertionError as e: write_result='Failed' print('断言出错啦:&#123;&#125;'.format(e)) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close()if __name__ == '__main__': unittest.main() 2.6.6 test_audit.py（测试审核的接口）2.6.7 test_bidloan.py（测试投资的接口）2.6.8 run.py]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化</tag>
        <tag>接口测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo与markdown语法简单汇总]]></title>
    <url>%2F2019%2F04%2F09%2Fhexo%E4%B8%8Emarkdown%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8D%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[hexo与markdown语法简单汇总hexo语法 hexo init —&gt;初始化本地文件夹为网站的根目录 hexo new post’博客名’ = hexo new ‘博客名’;简称:hexo n —&gt;新建文字(默认.md) hexo generate —&gt; 生成静态文件;简称:hexo g hexo deploy —&gt; 用于部署网站;简称:hexo d hexo server —&gt; 用于启动本地服务器;简称:hexo s5.1 hexo server -p —&gt;指定服务器端口,默认40005.2 hexo server -i —&gt;指定服务器ip地址,默认0.0.0.05.3 hexo server -s —&gt;静态模式,仅提供 public 文件夹中的文件并禁用文件监视 hexo g -d —&gt;指定生成后部署 hexo clean —&gt;用于清除缓存文件 markdown语法 标题1.1 一级标题—&gt;#1.2 二级标题—&gt;##1.3 三级标题—&gt;###1.4 四级标题—&gt;####1.5 五级标题—&gt;#####1.6 六级标题—&gt;###### 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 字体2.1 加粗—&gt;要加粗的内容2.2 斜体—&gt;要倾斜的内容2.3 斜体加粗—&gt;要斜体加粗的内容2.4 删除线—&gt;需要加删除线的内容 1234**要加粗的内容***要倾斜的内容****要斜体加粗的内容***~~需要加删除线的内容~~ 引用语法:&gt;需要引用的文字内容 12&gt; 这是引用的内容&gt;&gt; 这也是引用的内容 分割线-/*三个以上即可 1234-------******** 图片 1234 语法: ![图片alt](图片地址 "图片title")---&gt;title可不加 例如:![古风](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1555065335148&amp;di=e3e3187e01f54cd7bc807b3068230a40&amp;imgtype=0&amp;src=http%3A%2F%2Fp4.gexing.com%2FG1%2FM00%2F3F%2F3D%2FrBACJlTKBjPSVP1XAAEBEKmUep8763.jpg) 超链接 12345语法: [超链接名](超链接地址 "超链接title")--&gt;title可不加例如:[简书](http://jianshu.com)[百度](http://baidu.com) 列表 1234567 7.1 无序列表---&gt;-+*都可以(符号与内容之间都要有一个空格) 7.2 有序列表---&gt;数字加点(数字与内容之间也要有空格) 7.3 列表嵌套---&gt;上一级与下一级之间敲三个空格 * 测试数据 - 测试1 + 测试2 - 测试3 表格 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 代码9.1 单行代码:代码之间分别用一个反引号括起来 单行代码 单行代码内容9.2 多行代码:代码之间分别用三个反引号括起来 123代码内容代码内容代码... 流程图 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;]]></content>
      <categories>
        <category>简单语法汇总</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python自动化测试面试题]]></title>
    <url>%2F2019%2F04%2F04%2Fpython%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常见的python自动化测试的面试题目1. 对函数传参为可变型数据类型 进行改进 1234567def add(ele,mylist=[]): mylist.append(ele) return mylist print(add(4))print(add(5))print(add(6)) 运行结果如下图: 解决方法一:(最简单的方法,但是代码有点冗余) 1234567 def add(ele,mylist=[]): mylist.append(ele) return mylistprint(add(4,[]))print(add(5,[]))print(add(6,[])) 解决方法二:(推荐使用) 123456789 def add(ele,mylist=[]): if not mylist: mylist=[] mylist.append(ele) return mylistprint(add(4))print(add(5))print(add(6)) 解决方法三:(将默认参数修改为 不可变的类型) 1234567def add(ele,mylist=None): mylist.append(ele) return mylist print(add(4))print(add(5))print(add(6)) 2. 简述方法中__init__() 与__new__()的区别? 方法__new__()的特性1.1 __new__()用于创建实例,在实例创建之前调用,类级别的方法,是个静态方法1.2 __new__()至少有个参数cls,代表当前类,在实例化时由python解释器自动识别1.3 __new__()必须要返回值,返回实例对象 方法__init__()的特性2.1 __init__()用于初始化实例,在实例对象创建后被调用,对象级别的方法,用于设置对象的一些初始值2.2 __init__()至少有一个参数self,它是new()返回的实例,init()是在new()的基础上完成数据的初始化操作2.3 __init__()不需要返回值 __new__()的作用3.1 __new__() 用来继承一些不可变的class(比如:int,str,tuple)提供一个自定义类的实例化过程的途径 123class 子类名(int): def __new__(cls,value): return super(子类类名,cls).__new__(cls,abs(value)) 3.2 __new__()实现单例模式(每次初始化时只返回一个对象) 1234def __new__(cls): if not hasattr(cls,'instance'): cls.instance = super(子类类名,cls).__new__(cls) return cls.instance]]></content>
      <categories>
        <category>面试笔试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换主题踩得坑]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%B8%A9%E5%BE%97%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1. 使用hexo+github 搭建博客 更换主题 踩到的坑 使用别人的主题 修改theme 部署发布(hexo clean — hexo s) 登录本地服务器 (localhost:4000)界面出现: 解决方案:npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive(安装 Apollo Github 的依赖包) 本地就可以正常运行安装后,hexo clean —&gt;hexo s 部署到github上运行:安装后,hexo clean —&gt;hexo g—&gt;hexo d 本地样式正常,但是部署到github上 远程访问 样式发生改变(样式乱)原因: 修改根目录下的配置文件: _config.yml 将url进行修改 root 不需要修改 由于参考过网上: 将root由/—&gt;改为/你的项目名 但是经过测试,没有起到作用,可能因人而异吧 配置修改如下图:]]></content>
      <categories>
        <category>更换主题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>主题</tag>
      </tags>
  </entry>
</search>
