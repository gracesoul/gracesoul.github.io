<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python自动化面试编程题（一）]]></title>
    <url>%2F2019%2F05%2F16%2Fpython%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[python自动化测试面试—编程题 搜索引擎中会对用户输入的数据进行处理，第一步就是词法分析，分离字符串中的数字、中文、拼音、符号。比如这个字符串：我的是名字是ths,今年18岁语法分析后得到结果如下： 请编写程序实现该词法分析功能。数字：18中文：我的名字是 今年 岁拼音：ths符号：，。 1234567891011121314151617181920212223242526方法一：使用string 模块import stringnumber=[]chinese = []english=[]symbol=[]def find_data(s):for i in s: if i in string.digits: number.append(i) elif i in string.ascii_letters: english.append(i) elif i in string.punctuation: symbol.append(i) elif i in string.whitespace: symbol.append(i) else: chinese.append(i)print('数字是：&#123;&#125;'.format(''.join(number)))print('中文是：&#123;&#125;'.format(''.join(chinese)))print('字母是：&#123;&#125;'.format(''.join(english)))print('符号是：&#123;&#125;'.format(''.join(symbol)))if __name__ == '__main__':in_data = input('请输入你要解析的字符串：')find_data(in_data) 12345678910111213141516方法二：使用正则方法import redef find_data_re(s):patter = &#123;"数字":"\d","字母":"[a-zA-Z]","汉字":"[\u4e00-\u9fff]"&#125;for k,v in patter.items(): # print('键的内容：&#123;&#125;'.format(k)) # print ('值的内容：&#123;&#125;'.format (v)) # 取字典中的value值 result = re.findall(v,s) print(k+':'+''.join(result)) s = re.sub(v,'',s)print('符号：&#123;&#125;'.format(s))if __name__ == '__main__':in_data = input('请输入你要解析的字符串：')find_data_re(in_data) 编写程序实现:根据输入的数字打印菱形 12345678910111213141516171819202122232425262728293031323334353637383940n=5，输出： * ******** *** *n=6，输出： * ************* *** *n为任意大于1的正整数# 理解题意# 1.行数=输入的数 n=5-&gt;有5行# 2.*的个数 2n-1 n=1 第一行 2*1-1=1 第一行一个*# 3.星号+空格=输入的数字n# 4.前面的空格数 = 后面的空格数 = （n-星号数）/2 = 单边空格个数 (n=输入的数)def print_star(n): # 前半部分 for i in range(1,n+1,2): # 步调为 2 第一行1 第二行3 star_num = ' '*((n-i)//2)+'*'*i # ' '*((n-i)//2) 前面的空格数目 print(star_num) if n%2 == 0: # n为偶数 s = n-1 # n=6 那么下部分第一行只打印5个，所以打印 n-1 else: # n 为奇数 s = n-2 # 比如n=5,那么下半部份，第一行只打印3个 所以打印n-2 # 后半部分 for i in range(s,0,-2): star_num = ' ' * ((n - i) // 2) + '*' * i print(star_num)if __name__ == '__main__': print_star(5) 传入一个Json串，返回一个字典，字典只取出Json最底层的数据，中间如果有字符串也要进行处理，请以下面的数据为例，请用递归方法实现Json：{“a”:”aa”,”b”:[‘{“c”:”cc”,”d”:”dd”}’,{“f”:{“e”:”ee”}}]}输出：Dic:{‘a’:’aa’,’c’:’cc’,’d’:’dd’,’e’:’ee’} 1234567891011121314151617181920212223def str_to_dict(S): # S 是一个json字符串 dict_result=&#123;&#125; if type(S)== str: # S 是字符串 直接处理字符串 S = eval(S) # （字符串转为字典 不传给dict_result(因为字典里面还有其他的数据类型)） print('eval()后的S的值：&#123;&#125;,类型是：&#123;&#125;'.format(S,type(S))) if type (S) == list: # 判断是否是列表，遍历列表里面的内容 for i in S: d = str_to_dict(i) dict_result.update(d) if type(S)==dict: # 判断是否是字典 for k,v in S.items(): if type(v)==list or type(v)==dict: # 字典里面镶嵌着列表或者字典 d= str_to_dict(v) # （字典里面有列表和字典里面有字典） dict_result.update(d) else: dict_result[k]=v # 单纯是字典，就直接存在dict_result字典中 return dict_result # 返回底层字典 if __name__ == '__main__': J='&#123;"a":"aa","b":[\'&#123;"c":"cc","d":"dd"&#125;\',&#123;"f":&#123;"e":"ee"&#125;&#125;]&#125;' dict = str_to_dict(J) print(dict)]]></content>
      <categories>
        <category>自动化面试编程题</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins部署python项目踩得坑]]></title>
    <url>%2F2019%2F05%2F10%2Fjenkins%E9%83%A8%E7%BD%B2python%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%BE%97%E5%9D%91%2F</url>
    <content type="text"><![CDATA[jenkins部署python项目踩的坑项目：webservice项目部署到jenkins中，需要安装python项目中所需要的依赖环境在项目中 生成所有需要依赖的库 pip freeze &gt; requirements.txt在新的环境中 ，将所有的依赖包全部下载下来 pip install -r requirements.txt问题：pip不是内部或外部命令，也不是可运行的程序或批处理文件 步骤： jenkins配置 修改配置方式 保存后，点击立即构建 出现上述问题 检查pip或python是否配置环境变量 排除pip或者python未配置环境变量的问题，依旧无法解决上述问题 解决方案： win+r 进入终端窗口 进入该项目从github上pull下来的代码的路径 输入命令：pip install -r requirements.txt 输入命令：python run.py 发现终端运行是成功的，但是一样的路径，jenkins 构建 输入Windows批处理命令，运行出错，报pip出错 一直很奇怪这个问题，百度好久都没有找到解决方案 再次去查看 依赖包安装成功后的路径 发现suds模块安装到其他目录去了，没有按照到python目录下 将生产suds模块的文件夹找到，然后删除 重新安装 pip install -r requirements.txt 重新运行 jenkins运行成功 pip不是内部或外部命令，也不是可运行的程序或批处理文件 该问题完美解决（主要是第一次安装环境的时候，安装目录出错了）]]></content>
      <categories>
        <category>jenkins部署项目</category>
      </categories>
      <tags>
        <tag>jenkins构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重要网址记录大全]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%87%8D%E8%A6%81%E7%BD%91%E5%9D%80%E8%AE%B0%E5%BD%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[jenkins官网jenkins：https://jenkins.io/download/外文网（世界级）：https://www.edx.org慕课网：http://www.imooc.com/course/listw3school（在线编程基础知识）：http://www.w3cschool.cn/tutorial慕课学院：http://mooc.guokr.com/course/?dept_id=52&amp;order=hot学堂在线：http://www.xuetangx.com/LeetCode Online Judge(英文网，在线编程答疑)：https://leetcode.com/mooc中国：http://www.mooc.cn/]]></content>
      <categories>
        <category>网址记录</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins安装]]></title>
    <url>%2F2019%2F04%2F24%2Fjenkins%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[python自动化面试一]]></title>
    <url>%2F2019%2F04%2F22%2Fpython%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E4%B8%80%2F</url>
    <content type="text"><![CDATA[常见的python自动化测试的面试题目1. 给定一个只包含正整数的非空数组,返回该数组中重复次数最多的前N个数字,返回的结果按重复次数从多到少降序排列(N不存在取值非法的情况)12345678910111213141516方法一：def ele_sort(data,n): d=&#123;&#125; for i in data: d[i]=data.count(i) #将元素出现的次数 作为字典键值对的value值，组成（i:d[i]==&gt;元素：元素出现的次数） print(d.items()) #type(d.items())--&gt;&lt;class 'dict_items'&gt; sort_data = sorted(d.items(),key=lambda item:item[1],reverse=True) for i in range(0,n): print('排名第&#123;&#125;的元素：&#123;&#125;，出现了&#123;&#125;次'.format(i+1,sort_data[i][0],sort_data[i][1]))if __name__ == '__main__': l = [3, 4, 5, 3, 2, 5, 6, 2, 8, 9, 2, 4, 2, 5, 6, 3, 2, 4, 5, 5, 3, 2, 1, 5, 6, 5] n = int(input('请输入小于元素个数的正整数：')) ele_sort(l,n) 方法二：（使用set集合操作） 12345678910111213141516def data_sort(data,n): data_new = set(data) #将重复的数据去掉 d=&#123;&#125; for i in data_new: d[i]=data.count(i) print(d.items()) list_data = sorted(d.items(),key=lambda item:item[1],reverse=True) for i in range(0,n): print('排名第&#123;&#125;的元素：&#123;&#125;，出现&#123;&#125;次'.format(i+1,list_data[i][0],list_data[i][1]))if __name__ == '__main__': l = [3, 4, 5, 3, 2, 5, 6, 2, 8, 9, 2, 4, 2, 5, 6, 3, 2, 4, 5, 5, 3, 2, 1, 5, 6, 5] n=int(input('请输入小于元素个数&#123;&#125;的正整数：'.format(len(set(l))))) data_sort(l,n) 代码难点解读:123456789d.items()： 1. 它的数据类型是：dict_items 以列表返回可遍历的(键, 值) 元组数组 2. 注意：返回不是列表：是一个存放多个元祖的高仿列表，[(key,value),(key,value),(key,value)...] 3. 不能用下标，可用for循环sorted(d.items(),key=lambda item:item[1],reverse=True) 1. sorted(iterable,key,reverse)函数,参数key来决定我们根据那个字段对列表元素进行排序, 2. sorted(iterable，key，reverse)函数返回一个新列表，其中包含按升序排列的iterable中的所有项 3. key=lambda 元素: 元素[字段索引] 4. lambda item:item[1] 表示对元素第二个字段(就是 value)进行排序 2. 从字符串‘abcdba‘中找出第一个不重复的字符，方法不限方法一： 使用count()函数 （查看元素在数据中出现的次数）1234567891011def find_ele(data): for i in data: if data.count(i)==1: #元素在数据data出现的次数 print('第一个不重复的字符是：&#123;&#125;'.format(i)) breakif __name__ == '__main__': s= input('请输入随意的字符串：') find_ele(s) 方法二： 使用split()切割函数(切割后 长度为2 说明该元素只存在一个)1234567891011def find_ele(data): for i in data: if len (data.split (i)) == 2: # data='abcdba' data.split(a)===&gt;['','bcdb',''], data.split(b)===&gt;['a','cd','a'] print ('第一个不重复的字符是：&#123;&#125;'.format (i)) breakif __name__ == '__main__': s = input ('请输入随意的字符串：') find_ele (s)]]></content>
      <categories>
        <category>面试笔试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试之接口测试]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[python自动化测试之接口测试1. 项目框架的分层图: 2. 代码2.1 common文件夹2.1.1 do_request.py (发起http请求)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import requestsfrom interface_test.common.config import ReadConfigconfig = ReadConfig()class HttpRequest: ''' 公共使用一个session, cookies自动传递 这是一个操作http请求的类,使用这类的request方法去完成不同的HTTP请求，并且返回响应结果 ''' def __init__(self): #保证同一个session对象,便于cookies的自动传值 self.session = requests.session() def http_request(self,method,url,data=None,json=None): ''' :param method: 请求的方法 :param url: 请求的路径 :param data: 请求的数据 :param json: json类型的数据 :return: 返回请求响应的文本 ''' method = method.lower() #强制转化为小写 方便后期操作（大写也可以） if type(data)==str: # 将字符串转化为 字典形式的数据 data = eval(data) # 路径的拼接，根据线上环境或测试环境 进行路径的拼接 url = config.get_strvalue('api','pre_url')+url print('data的数据&#123;&#125;：'.format(data)) print('url的路径：',url) if method == 'get': resp = self.session.request(method=method,url=url,params=data) elif method == 'post': if json: resp = self.session.request(method=method,url=url,json=json) else: resp = self.session.request(method=method,url=url,data=data) else: print('暂不支持其他的请求方式!') print ('响应码:', resp.status_code) print ('响应文本:', resp.text) print ('响应的cookie:', resp.cookies) return resp def close(self): self.session.close()if __name__ == '__main__': # 注册接口 register_url = 'http://test.lemonban.com/futureloan/mvc/api/member/register' params = &#123;'mobilephone': '18871362019', 'pwd': '123456', 'regname': "test"&#125; resp = HttpRequest().http_request('post',url=register_url,data=params) print(resp.text) 2.1.2 do_excel.py (操作Excel的读写)123456789101112131415161718192021222324252627282930313233343536373839404142from openpyxl import load_workbookclass Case: def __init__(self): self.case_id =None self.title = None self.url=None self.data = None self.method = None self.expected = None self.actual = None self.result = Noneclass DoExcel: def __init__(self,file_name,sheet_name): self.file_name = file_name self.sheet_name = sheet_name def get_data(self): #Excel的读取数据操作 wb = load_workbook(self.file_name) sheet = wb[self.sheet_name] # 使用类与对象的思想进行操作 cases=[] for i in range(2,sheet.max_row+1): row_case=Case() #实例化对象 row_case.case_id = sheet.cell(row=i,column=1).value #对象调用属性 row_case.title = sheet.cell (row=i, column=2).value row_case.url = sheet.cell (row=i, column=3).value row_case.data = sheet.cell (row=i, column=4).value row_case.method = sheet.cell (row=i, column=5).value row_case.expected = sheet.cell (row=i, column=6).value cases.append(row_case) wb.close () return cases def write_back(self,row,col,value): #excel的写回操作 wb = load_workbook(self.file_name) sheet = wb[self.sheet_name] sheet.cell(row,col).value = value wb.save(self.file_name) wb.close() 2.1.3 contants.py (文件的路径)1234567891011121314import os# os.path.abspath(__file__) 动态获取当前文件的路径# os.path.dirname(os.path.abspath(__file__)) 动态获取当前文件的上一个文件夹的路径base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) #路径到了interface_test# print(base_dir)# 测试用例 Excel文件case_file = os.path.join(base_dir,'data','cases.xlsx')# print(case_file)# 有关线上环境与测试环境的网址切换的配置文件global_config_file = os.path.join(base_dir,'config','global.cfg')online_config_file = os.path.join(base_dir,'config','online.cfg')test_config_file = os.path.join(base_dir,'config','test.cfg') 2.1.4 config.py(配置文件的读取)1234567891011121314151617181920212223242526272829from configparser import ConfigParserfrom interface_test.common.contants import *class ReadConfig: def __init__(self,encoding='utf-8'): self.cf = ConfigParser() #打开配置文件 self.cf.read(global_config_file,encoding) #先加载global.cfg配置文件 switch = self.cf.getboolean('switch','on') #读取global.cfg配置文件的switch的值 if switch: # on=True 开关打开的时候,加载的是线上环境的配置 self.cf.read(online_config_file,encoding) else: self.cf.read(test_config_file,encoding) def get_strvalue(self,section,option): # 获取字符串 return self.cf.get(section,option) def get_intvalue(self,section,option): # 获取整数 return self.cf.getint(section,option) def get_boolvalue(self,section,option): # 获取布尔值 return self.cf.getboolean(section,option)if __name__ == '__main__': config = ReadConfig() value = config.get_boolvalue('switch','on') # value = config.get_strvalue('api','pre_url') print(value) 2.1.5 do_mysql(操作数据库)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import pymysqlfrom interface_test.common.config import ReadConfigconfig = ReadConfig ()class DoMysql: # 1.建立连接 # 2.新建一个查询界面 # 3.编写sql语句 # 4.执行SQL语句 # 5.查看结果 # 6.关闭查询 # 7.关闭数据库 def __init__(self): # db_host = 'test.lemonban.com' # db_user = 'test' # db_password = 'test' # db_database = 'future' # db_port = 3306 # 读取数据库的配置文件的值（在online.cfg的配置文件中，section：db_test 下的值） db_host = config.get_strvalue('db_test','db_host') db_user = config.get_strvalue('db_test','db_user') db_password = config.get_strvalue('db_test','db_password') db_database = config.get_strvalue('db_test','db_database') db_port = config.get_intvalue('db_test','db_port') self.db = pymysql.connect (host=db_host, user=db_user, password=db_password, database=db_database, port=db_port,charset='utf8') self.cursor= self.db.cursor () # 创建游标 def fetch_one(self,sql): # 查询一条数据 self.cursor.execute(sql) return self.cursor.fetchone() def fetch_all(self,sql): # 查询所有的数据 self.cursor.execute(sql) return self.cursor.fetchall() def close(self): self.cursor.close() # 关闭查询 self.db.close() # 关闭数据库连接if __name__ == '__main__': my_sql = DoMysql () sql = 'select max(mobilephone) from future.member' #获取数据库中最大的手机号 result = my_sql.fetch_one(sql) print(result) 2.1.6 re_context(正则匹配操作)123456789101112131415161718import refrom interface_test.common.config import ReadConfigconfig = ReadConfig()def replace_data(data): # 1.正则表达式 regular = '#(.*?)#' # 2.查找要匹配的字符串 # search() 扫描字符串，寻找与模式匹配的字符串,返回匹配对象，如果没有找到匹配，则为None while re.search(regular,data): # 找到匹配的对象 find_data = re.search (regular, data) find_key = find_data.group(1) # 拿到参数化的KEY find_value = config.get_strvalue('data',find_key) #拿配置文件里面的值 # sub(pattern, repl, string, count=0, flags=0)有返回值 # pattern正则表达式 repl要替换的数据 string--》data count 替换的次数 data = re.sub(regular,find_value,data,count=1) return data 2.2 config文件夹 （配置文件的操作）2.2.1 global.cfg（控制线上环境或者测试环境的开关）123[switch]on = True;on = False 2.2.2 online.cfg（线上环境）123456789[api]pre_url = http://test.lemonban.com/futureloan/mvc/api[db_test]db_host = test.lemonban.comdb_user = testdb_password = testdb_database = futuredb_port = 3306 2.2.3 test.cfg（测试环境）12[api]pre_url = http://47.107.168.87:8080/futureloan/mvc/api 2.3 data文件夹（存放测试用例的Excel文件）2.3.1 cases.xlsx （测试用例） 注册用例 登录用例 2.4 log文件夹（日志记录文件）2.4.1 my_log.py（日志操作）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import loggingclass MyLog: '''这是一个记录log日志的类''' def my_log(self,level,msg): ''' :param level: 日志的等级 :param msg: 需要输出的提示信息 :return: ''' # 收集器 - --创建一个日志收集器, getLogger()函数 my_logger = logging.getLogger('test_request') my_logger.setLevel('DEBUG') #设置等级 #设定日志输出格式 formatter = logging.Formatter ('%(asctime)s-' '[%(levelname)s]-' '[line:%(lineno)d]-''[日志信息]:%(message)s') #设定输出渠道---&gt;控制台 sh = logging.StreamHandler() sh.setLevel('ERROR') sh.setFormatter(formatter) #设定输出渠道----&gt;指定文件 fh = logging.FileHandler('test.log',encoding='utf-8') fh.setLevel('INFO') fh.setFormatter(formatter) #日志收集器与输出渠道进行对接 my_logger.addHandler (sh) my_logger.addHandler(fh) if level == 'DEBUG': my_logger.debug(msg) elif level=='INFO': my_logger.info(msg) elif level == 'WARNING': my_logger.warning(msg) elif level =='ERROR': my_logger.error(msg) else: my_logger.critical(msg) # 去掉日志的重复 每次收集完毕之后 移除掉日志收集器 my_logger.removeHandler(sh) my_logger.removeHandler(fh) #重新封装五个不同等级的日志级别的函数 def debug(self,msg): self.my_log('DEBUG',msg) def info(self,msg): self.my_log('INFO',msg) def warning(self,msg): self.my_log('WARNING',msg) def error(self,msg): self.my_log('ERROR',msg) def critical(self,msg): self.my_log('CRITICAL',msg)if __name__ == '__main__': log = MyLog() log.debug('这是个调试的信息') 2.5 report文件夹 （测试报告）2.5.1 report.html(这是自动生成的) 2.6 testcases文件夹（存放测试用例的方法）2.6.1 test_register.py（测试注册接口）123456789101112131415161718192021222324252627282930313233343536373839404142434445import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.do_mysql import DoMysqldo_excel = DoExcel(case_file,'register')register_cases = do_excel.get_data()@ddtclass RegisterTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() cls.mysql = DoMysql () # 创建数据库的连接 @data(*register_cases) def test_register(self,case): if case.data.find('register_mobile')&gt;-1: #测试用例中找到register_mobile sql = 'select max (mobilephone) from future.member' max_phone = self.mysql.fetch_one(sql)[0] # 得到的数据是元组，需要取里面的第一个值（索引） max_phone = int(max_phone)+1 # 将数据库中最大的手机号+1，保证该手机号未被注册 # replace()函数 是替换之后重新返回一个新的字符串，有返回值 需要变量去接收 case.data= case.data.replace('register_mobile',str(max_phone)) # 替换参数值 resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.text) write_result = 'Pass' except AssertionError as e: write_result = 'Failed' print('断言出错:&#123;&#125;'.format(e)) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close() cls.mysql.close()if __name__ == '__main__': unittest.main() 2.6.2 test_login.py（测试登录接口）1234567891011121314151617181920212223242526272829303132333435363738import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.re_context import replace_datado_excel = DoExcel (case_file, 'login')login_cases = do_excel.get_data ()@ddtclass LoginTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest () @data(*login_cases) def test_login(self,case): case.data = replace_data(case.data) #参数化 正则匹配解析 resp =self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.json()['msg']) write_result = 'Pass' except AssertionError as e: write_result = 'Failed' print('断言错误：&#123;&#125;'.format(e)) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close()if __name__ == '__main__': unittest.main() 2.6.3 test_recharge.py（测试充值接口）123456789101112131415161718192021222324252627282930313233343536373839import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.re_context import replace_datado_excel = DoExcel (case_file, 'recharge')withdraw_cases = do_excel.get_data ()@ddtclass WithdrawTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() @data(*withdraw_cases) def test_withdraw(self,case): case.data = replace_data(case.data) #参数化 正则匹配解析 resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.json()['msg']) write_result = 'Pass' except AssertionError as e: write_result='Failed' print('断言出错：',e) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close()if __name__ == '__main__': unittest.main() 2.6.4 test_withdraw.py（测试取现的接口）123456789101112131415161718192021222324252627282930313233343536373839import unittestfrom ddt import ddt,datafrom interface_test.common.do_excel import DoExcelfrom interface_test.common.do_request import HttpRequestfrom interface_test.common.contants import *from interface_test.common.re_context import replace_datado_excel = DoExcel (case_file, 'withdraw')withdraw_cases = do_excel.get_data ()@ddtclass WithdrawTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() @data(*withdraw_cases) def test_withdraw(self,case): case.data = replace_data(case.data) #参数化 正则匹配解析 resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.json()['msg']) write_result = 'Pass' except AssertionError as e: write_result='Failed' print('断言出错：',e) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id+1,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close()if __name__ == '__main__': unittest.main() 2.6.5 test_addloan.py（测试添加标的接口）12345678910111213141516171819202122232425262728293031323334353637383940import unittestfrom ddt import ddt,datafrom interface_practice.common.do_request import HttpRequestfrom interface_practice.common.do_excel import DoExcelfrom interface_practice.common.contants import *from interface_test.common.re_context import replace_datado_excel = DoExcel(case_file,'add_loan')addloan_cases = do_excel.get_data()@ddtclass AddloanTest(unittest.TestCase): @classmethod def setUpClass(cls): cls.do_request = HttpRequest() @data(*addloan_cases) def test_addloan(self,case): # print('转换前的数据：',case.data) #&#123;"mobilephone": "#normal_user#", "pwd": "#normal_pwd#"&#125; case.data = replace_data(case.data) # print('转换后的数据：',case.data) #&#123;"mobilephone": "17786426991", "pwd": "123456"&#125; resp = self.do_request.http_request(case.method,case.url,case.data) try: self.assertEqual(case.expected,resp.json()['msg']) write_result = "Pass" except AssertionError as e: write_result='Failed' print('断言出错啦:&#123;&#125;'.format(e)) raise e finally: do_excel.write_back(case.case_id+1,7,resp.text) do_excel.write_back(case.case_id,8,write_result) @classmethod def tearDownClass(cls): cls.do_request.close()if __name__ == '__main__': unittest.main() 2.6.6 test_audit.py（测试审核的接口）2.6.7 test_bidloan.py（测试投资的接口）2.6.8 run.py]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化</tag>
        <tag>接口测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo与markdown语法简单汇总]]></title>
    <url>%2F2019%2F04%2F09%2Fhexo%E4%B8%8Emarkdown%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8D%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[hexo与markdown语法简单汇总hexo语法 hexo init —&gt;初始化本地文件夹为网站的根目录 hexo new post’博客名’ = hexo new ‘博客名’;简称:hexo n —&gt;新建文字(默认.md) hexo generate —&gt; 生成静态文件;简称:hexo g hexo deploy —&gt; 用于部署网站;简称:hexo d hexo server —&gt; 用于启动本地服务器;简称:hexo s5.1 hexo server -p —&gt;指定服务器端口,默认40005.2 hexo server -i —&gt;指定服务器ip地址,默认0.0.0.05.3 hexo server -s —&gt;静态模式,仅提供 public 文件夹中的文件并禁用文件监视 hexo g -d —&gt;指定生成后部署 hexo clean —&gt;用于清除缓存文件 markdown语法 标题1.1 一级标题—&gt;#1.2 二级标题—&gt;##1.3 三级标题—&gt;###1.4 四级标题—&gt;####1.5 五级标题—&gt;#####1.6 六级标题—&gt;###### 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 字体2.1 加粗—&gt;要加粗的内容2.2 斜体—&gt;要倾斜的内容2.3 斜体加粗—&gt;要斜体加粗的内容2.4 删除线—&gt;需要加删除线的内容 引用语法:&gt;需要引用的文字内容 12&gt; 这是引用的内容&gt;&gt; 这也是引用的内容 分割线-/*三个以上即可 1234-------******** 图片 1234 语法: ![图片alt](图片地址 "图片title")---&gt;title可不加 例如:![古风](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1555065335148&amp;di=e3e3187e01f54cd7bc807b3068230a40&amp;imgtype=0&amp;src=http%3A%2F%2Fp4.gexing.com%2FG1%2FM00%2F3F%2F3D%2FrBACJlTKBjPSVP1XAAEBEKmUep8763.jpg) 超链接 12345语法: [超链接名](超链接地址 "超链接title")--&gt;title可不加例如:[简书](http://jianshu.com)[百度](http://baidu.com) 列表 1234567 7.1 无序列表---&gt;-+*都可以(符号与内容之间都要有一个空格) 7.2 有序列表---&gt;数字加点(数字与内容之间也要有空格) 7.3 列表嵌套---&gt;上一级与下一级之间敲三个空格 * 测试数据 - 测试1 + 测试2 - 测试3 表格 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 代码9.1 单行代码:代码之间分别用一个反引号括起来 单行代码 单行代码内容9.2 多行代码:代码之间分别用三个反引号括起来 123代码内容代码内容代码... 流程图 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;]]></content>
      <categories>
        <category>简单语法汇总</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python自动化测试面试题]]></title>
    <url>%2F2019%2F04%2F04%2Fpython%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常见的python自动化测试的面试题目1. 对函数传参为可变型数据类型 进行改进1234567def add(ele,mylist=[]): mylist.append(ele) return mylist print(add(4))print(add(5))print(add(6)) 运行结果如下图: 解决方法一:(最简单的方法,但是代码有点冗余) 1234567 def add(ele,mylist=[]): mylist.append(ele) return mylistprint(add(4,[]))print(add(5,[]))print(add(6,[])) 解决方法二:(推荐使用) 123456789 def add(ele,mylist=[]): if not mylist: mylist=[] mylist.append(ele) return mylistprint(add(4))print(add(5))print(add(6)) 解决方法三:(将默认参数修改为 不可变的类型) 1234567def add(ele,mylist=None): mylist.append(ele) return mylist print(add(4))print(add(5))print(add(6)) 2. 简述方法中__init__() 与__new__()的区别? 方法__new__()的特性1.1 __new__()用于创建实例,在实例创建之前调用,类级别的方法,是个静态方法1.2 __new__()至少有个参数cls,代表当前类,在实例化时由python解释器自动识别1.3 __new__()必须要返回值,返回实例对象 方法__init__()的特性2.1 __init__()用于初始化实例,在实例对象创建后被调用,对象级别的方法,用于设置对象的一些初始值2.2 __init__()至少有一个参数self,它是new()返回的实例,init()是在new()的基础上完成数据的初始化操作2.3 __init__()不需要返回值 __new__()的作用3.1 __new__() 用来继承一些不可变的class(比如:int,str,tuple)提供一个自定义类的实例化过程的途径 123class 子类名(int): def __new__(cls,value): return super(子类类名,cls).__new__(cls,abs(value)) 3.2 __new__()实现单例模式(每次初始化时只返回一个对象) 1234def __new__(cls): if not hasattr(cls,'instance'): cls.instance = super(子类类名,cls).__new__(cls) return cls.instance]]></content>
      <categories>
        <category>面试笔试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换主题踩得坑]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%B8%A9%E5%BE%97%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1. 使用hexo+github 搭建博客 更换主题 踩到的坑 使用别人的主题 修改theme 部署发布(hexo clean — hexo s) 登录本地服务器 (localhost:4000)界面出现: 解决方案:npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive(安装 Apollo Github 的依赖包) 本地就可以正常运行安装后,hexo clean —&gt;hexo s 部署到github上运行:安装后,hexo clean —&gt;hexo g—&gt;hexo d 本地样式正常,但是部署到github上 远程访问 样式发生改变(样式乱)原因: 修改根目录下的配置文件: _config.yml 将url进行修改 root 不需要修改 由于参考过网上: 将root由/—&gt;改为/你的项目名 但是经过测试,没有起到作用,可能因人而异吧 配置修改如下图:]]></content>
      <categories>
        <category>更换主题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>主题</tag>
      </tags>
  </entry>
</search>
